
<!DOCTYPE html>
<meta charset="utf-8">
<title>Internet connectivity around the world</title>
<style>
    @import url(maps.css);

    .graticule {
        fill: none;
        stroke: #000;
        stroke-opacity: .3;
        stroke-width: .5px;
    }

    .graticule.outline {
        stroke: #333;
        stroke-opacity: 1;
        stroke-width: 1.5px;
    }

    path {
        //stroke: #000;
    }

    .background {
        stroke: none;
        fill: #eee;
    }

    #leftColumn {
        width: 55%;
        float: left;
    }

    #rightColumnUp {
        width: 45%;
        height: 50%;
        float: right;
    }

    #rightColumnDown {
        width: 45%;
        height: 50%;
        float: right;
    }




    .axis path{
        stroke-width: 0;
    }
    .axis line {
        stroke: lightgray;
        opacity: 0.8;
    }


    .cities {
        fill: none;
        stroke: #aaa;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-width: 1.25px;
    }


    .country--active {
        stroke-width: 2.75px;
        z-index: 10;
    }

    .textbox{  
        width: 60px;                  
        height: 28px;                 
        padding: 2px;             
        font: 12px sans-serif; 
        background: lightsteelblue;   
        border: 0px;      
        border-radius: 8px;           

    }
    .text {
        //background: lightsteelblue;   

        text-anchor: middle;
        text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
    }

    .pathVoronoi{
        fill: none;
        pointer-events: all;

    }

    .pathMap {
        stroke: #000;
    }

    .voronoi > path {
        //fill: none;
        //pointer-events: all;
    }

    .focus {
        background: #242424;
        background-color: #242424;
    }

    .d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}

</style>
<div id="leftColumn">
    <h1>Internet Connectivity in the world</h1>
    <div id="map"></div>
    <br />
    <br />
    <br />
    <br />
    <select id="yearSelect" onchange="yearSelect()">
        <option value="1990.0">1990</option>
        <option value="1991.0">1991</option>
        <option value="1992.0">1992</option>
        <option value="1993.0">1993</option>
        <option value="1994.0">1994</option>
        <option value="1995.0">1995</option>
        <option value="1996.0">1996</option>
        <option value="1997.0">1997</option>
        <option value="1998.0">1998</option>
        <option value="1999.0">1999</option>
        <option value="2000.0">2000</option>
        <option value="2001.0">2001</option>
        <option value="2002.0" selected="selected">2002</option>
        <option value="2003.0">2003</option>
        <option value="2004.0">2004</option>
        <option value="2005.0">2005</option>
        <option value="2006.0">2006</option>
        <option value="2007.0">2007</option>
        <option value="2008.0">2008</option>
        <option value="2009.0">2009</option>
        <option value="2010.0">2010</option>
        <option value="2011.0">2011</option>
        <option value="2012.0">2012</option>
    </select>

</div>
<div id="rightColumnUp"> 
    <div id="lineGraph"></div>
</div>
<div id="rightColumnDown"> 
    <div id="bubbleChart">
    </div>

    <script src="d3.min.js?3.1"></script>
    <script src="d3.geo.projection.min.js"></script>
    <script src="topojson.min.js?1.1.0"></script>
    <script src="d3.queue.js"></script>
    <script src="dimple.v2.1.2.js"></script>
    <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
    <script>
        //Globals
        var countryNames;
        var worldData;
        var internetData;
        var currentYear = "2002.0";
        var linearColorScale = d3.scale.linear()
                .domain([0.0, 100.0])
                .range([0, 1])
        var hoverCountry;

        var colorInterpolator = d3.interpolateHsl("white", "green");
        var years;
        var margin = {top: 20, right: 30, bottom: 30, left: 40};
        var widthLine = document.getElementById("rightColumnUp").offsetWidth - margin.left - margin.right;
        var heightLine = document.getElementById("rightColumnUp").offsetWidth * 500 / 960 - margin.top - margin.bottom;
        //console.log(widthLine + " X " + heightLine);
        var formatxAxis = d3.format('04d');
        //array which holds which countries are selected
        var selectedCountries = [];
        //array which holds which country has which color	
        var countryColors = [{
                countryName: null,
                color: "#377eb8"
            }, {
                countryName: null,
                color: "#984ea3"
            }, {
                countryName: null,
                color: "#ff7f00"
            }, {
                countryName: null,
                color: "#ffff33"
            }, {
                countryName: null,
                color: "#a65628"
            }, {
                countryName: null,
                color: "#f781bf"
            }];
        //TODO More colors?

        var x = d3.scale.linear()
                .range([0, widthLine]);
        var y = d3.scale.linear()
                .range([heightLine, 0]);
        var color = d3.scale.category20();
        var voronoi = d3.geom.voronoi()
                .x(function (d) {
                    return x(d.year);
                })
                .y(function (d) {
                    return y(d.value);
                })
                .clipExtent([[-margin.left, -margin.top], [widthLine + margin.right, heightLine + margin.bottom]]);
        var line = d3.svg.line()
                .x(function (d) {
                    return x(d.year);
                })
                .y(function (d) {
                    return y(d.value);
                });
        var svg = d3.select("#lineGraph").append("svg")
                .attr("width", widthLine + margin.left + margin.right)
                .attr("height", heightLine + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        function type(d, i) {
            years = Object.keys(d).filter(Number);
            var country = {
                countryName: d.countryName,
                values: null
            };
            country.values = years.map(function (y) {
                return {
                    country: country,
                    year: y,
                    value: Math.abs(d[y] / 100),
                    originalYear: Math.floor(y) + ".0",
                    originalValue: d[Math.floor(y) + ".0"] / 100
                };
            });
            return country;
        }



        //Max Code /\
        var svgBubble = dimple.newSvg("#bubbleChart", document.getElementById("rightColumnDown").offsetWidth, document.getElementById("rightColumnUp").offsetWidth * 400 / 590);

        d3.selection.prototype.moveToFront = function () {
            return this.each(function () {
                this.parentNode.appendChild(this);
            });
        };
        //returns the color assigned to coutnryName
        function getAndSetAvailableColor(countryName)
        {
            //some returns as soon as something returns true
            for (var i = 0; i < countryColors.length; i++)
            {
                var cc = countryColors[i];
                if (cc.countryName == null)
                {
                    cc.countryName = countryName;
                    return cc.color;
                }
            }
            return false;
        }
        //frees up the color assigned to countryName
        function unsetColor(countryName)
        {
            //some returns as soon as something returns true
            for (var i = 0; i < countryColors.length; i++)
            {
                var cc = countryColors[i];
                if (cc.countryName == countryName)
                {
                    cc.countryName = null;
                }
            }
        }

        function getNextAvailableColor()
        {
            //some returns as soon as something returns true
            for (var i = 0; i < countryColors.length; i++)
            {
                var cc = countryColors[i];
                if (cc.countryName == null)
                {
                    return cc.color;
                }
            }
            return false;
        }
        function getCountryColor(name)
        {
            //some returns as soon as something returns true
            for (var i = 0; i < countryColors.length; i++)
            {
                var cc = countryColors[i];
                if (cc.countryName == name)
                {
                    return cc.color;
                }
            }
            return false;
        }


        var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    return "<strong>CountryName:</strong> <span style='color:red'>"+ d.countryName +"</span><br /><strong>Connectivity in " + Math.round(currentYear) + ": </strong> " + Math.round(d.conn*1000)/10 + "%<br />Growth in " + Math.round(currentYear) + ": " + Math.round(d.growth*1000)/10 + "%";
  });
  var tipLine = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    console.log(d);
    return "<strong>CountryName:</strong> <span style='color:red'>"+ d.country.countryName +"</span><br /><strong>Connectivity in " + Math.round(d.originalYear) + ": </strong> " + Math.round(Math.abs(d.value)*1000)/10 + "%";
  });

        //Rik Code \/
        var isDorling = false;
        var widthMap = document.getElementById("leftColumn").offsetWidth,
                heightMap = document.getElementById("leftColumn").offsetWidth / 1020 * 600;
        var projection = d3.geo.mollweide()
                .scale(180)
                .translate([widthMap / 2, heightMap / 2]);
        var path = d3.geo.path()
                .projection(projection);
        var force = d3.layout.force()
                .size([widthMap, heightMap]);
        var graticule = d3.geo.graticule();
        var color = d3.scale.category10();
        var svgMap = d3.select("#map").append("svg")
                .attr("width", widthMap)
                .attr("height", heightMap + 50);
        svgMap.append("path")
                .attr("class", "pathMap")
                .datum({type: "Sphere"})
                .attr("class", "background")
                .attr("d", path);
                svgMap.call(tip);
                svg.call(tipLine);
        queue()
                .defer(d3.tsv, "internetAdaptedV2.csv", type)
                .defer(d3.tsv, "world-country-names.tsv")
                .defer(d3.json, "world-110m.json")
                //.defer(d3.tsv, "cities-data.txt", function(d) { cityData.set(d.Code, +d.AUTO_TOT); })
                .await(dataLoaded);
        function dataLoaded(error, loadedInternetData, loadedCountryNames, loadedWorldPolygons) {
            //Store loaded data
            countryNames = loadedCountryNames;
            internetData = loadedInternetData;
            worldData = loadedWorldPolygons;
            //Initalize graphics
            initializeWorldMap(worldData);
            initializeLineGraph(internetData);
            drawBubbleChart(internetData);
        }

        var myChart;
        var bubbleCount = 0;
        function drawBubbleChart(internetData) {

            document.getElementById('bubbleChart').getElementsByTagName('svg')[0].innerHTML = ""
            data = extractData(internetData);
            //data = dimple.filterData(internetData, "countryName", selectedCountries);
            myChart = new dimple.chart(svgBubble, data);
            myChart.setBounds(60, 30, 500, 330)
            var x = myChart.addCategoryAxis("x", "Year");
            x.addOrderRule("Year");
            myChart.addMeasureAxis("y", "Growth");
            mySeries = myChart.addSeries("Country", dimple.plot.bubble);

            myChart.addLegend(140, 10, 360, 20, "right");
            myChart.data.forEach(function (d) {
                if (d.Country == hoverCountry)
                {
                    //TODO use a better stroke
                    if (isCountrySelected(d.Country)) {
                        myChart.assignColor(d.Country, "black");
                    } else {
                        myChart.assignColor(d.Country, "red");
                    }
                } else {
                    myChart.assignColor(d.Country, getCountryColor(d.Country));
                }
            });
            //TODO set mouseOver to also mouseOver other 2 graphs
            myChart.draw();

            mySeries.shapes.on("mouseover", function (e) {
                console.log("mouse on dimple");
                dimple._showPointTooltip(e, this, myChart, mySeries);
                var countryName = e.aggField[0];
                if (bubbleCount <= 0)
                {
                    bubbleCount = 2;
                    mouseOverGlobal(countryName, true);
                } else {
                    mouseOverGlobal(countryName, false);
                }
            });
            mySeries.shapes.on("mouseleave", function (e) {
                console.log("Mouse leaving dimple")
                dimple._removeTooltip(e, this, myChart, mySeries);
                var countryName = e.aggField[0];
                bubbleCount--;
                if (bubbleCount <= 0)
                {
                    mouseOutGlobal(countryName, true);
                } else {
                    mouseOutGlobal(countryName, false);
                }
            });
        }

        //extracts the data for the bubble chart
        function extractData(internetData) {
            //console.log(internetData);
            data = [];
            internetData.forEach(function (c) {
                if ((selectedCountries.indexOf(c.countryName) >= 0) || c.countryName == hoverCountry) {
                    for (var i = 1990.0; i < 2013.0; i++) {
                        var obj = {};
                        obj.Year = i;
                        obj.Country = c.countryName;
                        if (i == 1990.0) {
                            obj.Growth = 0;
                        }
                        else {
                            var connectivityThisYear = parseFloat(getConnectivity(c.countryName, i + ".0"));
                            //console.log(connectivityThisYear);
                            if (connectivityThisYear == 0) {
                                connectivityThisYear = 0.0001;
                            }
                            var connectivityLastYear = parseFloat(getConnectivity(c.countryName, (i - 1) + ".0"));
                            if (connectivityLastYear == 0) {
                                connectivityLastYear = 0.0001;
                            }
                            //console.log(connectivityThisYear - connectivityLastYear);
                            obj.Growth = connectivityThisYear - connectivityLastYear;
                        }
                        obj.Connectivity = c[i];
                        obj.Color = color(getCountryColor(c.countryName));
                        data.push(obj);
                    }//end of i loop
                }
            });
            return data;
        }


        function initializeLineGraph(worldData) {
            x.domain(d3.extent(years));
            y.domain([0, d3.max(worldData, function (c) {
                    return d3.max(c.values, function (d) {
                        return d.value;
                    });
                })]).nice();
            svg.append("g")
                    .attr("class", "axis axis--x")
                    .attr("transform", "translate(0," + heightLine + ")")
                    .call(d3.svg.axis()
                            .scale(x)
                            .orient("bottom")
                            .tickSize(-heightLine, 0, 0)
                            .tickFormat(formatxAxis));
            svg.append("g")
                    .attr("class", "axis axis--y")
                    .call(d3.svg.axis()
                            .scale(y)
                            .orient("left")
                            .tickSize(-widthLine, 0, 0)
                            .ticks(10, "%"))
                    .append("text")
                    .attr("x", 4)
                    .attr("dy", ".32em")
                    .style("font-weight", "bold")
                    .text("Internet connectivity percentage");
            svg.append("g")
                    .attr("class", "cities")
                    .selectAll("path")
                    .attr("class", "pathVoronoi")
                    .data(worldData)
                    .enter().append("path")
                    .attr("class", "pathVoronoi")
                    .attr("d", function (d) {
                        d.line = this;
                        return line(d.values);
                    });

            var focus = svg.append("g")
                    .attr("transform", "translate(-100,-100)")
                    .attr("class", "focus");
            focus.append("circle")
                    .attr("r", 3.5);
            focus.append("text")
                    .attr("y", -10);
            focus.append("textbox")
                    .attr("y", -20)
                    .attr("width", "20px")
                    .attr("height", "20px")
                    .attr("background-color", "#242424");
            var voronoiGroup = svg.append("g")
                    .attr("class", "voronoi");
            voronoiGroup.selectAll("path")
                    .attr("class", "pathVoronoi")
                    .data(voronoi(d3.nest()
                            .key(function (d) {
                                return x(d.year) + "," + y(d.value);
                            })
                            .rollup(function (v) {
                                return v[0];
                            })
                            .entries(d3.merge(worldData.map(function (d) {
                                return d.values;
                            })))
                            .map(function (d) {
                                return d.values;
                            })))
                    .enter().append("path")
                    .attr("class", "pathVoronoi")
                    .attr("d", function (d) {
                        if (d !== undefined)
                        {
                            return "M" + d.join("L") + "Z";
                        }
                    })
                    .datum(function (d) {
                        if (d !== undefined)
                        {
                            return d.point;
                        }
                    })
                    .on("mouseover", function(d) { tipLine.show(d); mouseOverLine(d); })
                    .on("mouseout", function(d) { tipLine.hide(d); mouseOutLine(d); })
                    .on("mousedown", mouseClickLine);

            function mouseOverLine(d) {
                var countryName = d.country.countryName;
                mouseOverGlobal(countryName);

                //show tooltip
                focus.attr("transform", "translate(" + x(d.year) + "," + y(d.value) + ")");
                focus.select("text").html("country: " + countryName + "\r\n" +
                        "Year " + d.originalYear.substring(0, 4) + "\r\n" +
                        "internetConnectity: " + (Math.round(d.originalValue * 100) / 100) + "%");
                //TODO Get textBox to work so we display this properly
            }
            function mouseOutLine(d) {
                var countryName = d.country.countryName;
                mouseOutGlobal(countryName);
                //set tooltip out of bounds so we don't see it
                focus.attr("transform", "translate(-100,-100)");
            }


            function mouseClickLine(d) {
                var countryName = d.country.countryName;
                mouseClickGlobal(countryName);
            }
        }



        function findLineCountry(countryName)
        {
            //find the country in the line chart
            var path = d3.select("g.cities").selectAll("path").filter(function (d) {
                if (d.countryName === countryName)
                {
                    return d;
                }
            })[0][0];
            var country = path.__data__;
            return country;
        }


        function isCountrySelected(countryName)
        {
            var index = selectedCountries.indexOf(countryName);
            if (index === -1)
            {
                return false;
            } else {
                return true;
            }
        }


        function initializeWorldMap(worldData) {

            setLinearColorScale();
            var neighbors = topojson.neighbors(worldData.objects.countries.geometries);
            var land = {
                type: "GeometryCollection",
                geometries: polygons(worldData.objects.countries.geometries),
            };
            var neighbors = topojson.neighbors(land.geometries);
//              console.log(neighbors)
            var nodes = topojson.feature(worldData, land).features.map(function (d) {
                exterior(d.geometry);
                var centroid = path.centroid(d.geometry);
                var countryName = getCountryNameFromId(land.geometries[d.id - 1].countryId);
                var newRadius = Math.sqrt(getConnectivity(countryName, currentYear)) * 2;
                if (newRadius < 0) {
                    newRadius = newRadius * -1;
                }

                return {
                    countryId: land.geometries[d.id - 1].countryId,
                    x: centroid[0],
                    y: centroid[1],
                    ox: centroid[0],
                    oy: centroid[1],
                    geometry: d.geometry,
                    dorling: dorling(d.geometry, newRadius)
                };
            });

            var links = d3.merge(neighbors.map(function (neighbors, i) {
                var source = nodes[i];
                return neighbors.map(function (target) {
                    target = nodes[target];
                    return {source: source, target: target, distance: source.dorling.radius + target.dorling.radius};
                });
            }));
            mergeNodes(nodes);
            var node = svgMap.selectAll("g")
                    .data(nodes)
                    .attr("id", function (data) {
                        return d.id;
                    })
                    .enter().insert("g", ".graticule")
                    .attr("transform", function (d) {
                        return "translate(" + -d.x + "," + -d.y + ")";
                    })
                    .append("path")
                    .attr("class", "pathMap")
                    .attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    })
                    .attr("d", function (d) {
                        return path(d.geometry);
                    })
                    .attr("name", function (d) {
                        return getCountryNameFromId(d.countryId);
                    })
                    .on('mouseover', function (d) {
                      var countryName = getCountryNameFromId(d.countryId);
                      var conn = getConnectivity(countryName, currentYear);
                      var growth = getGrowthInYear(countryName, currentYear);
                      d.countryName = countryName;
                      d.conn = conn;
                      d.growth = growth;
                      console.log(d);
                      tip.show(d);
                        mouseOverGlobal(getCountryNameFromId(d.countryId));
                    })
                    .on('mouseout', function (d) {
                      tip.hide(d);
                        mouseOutGlobal(getCountryNameFromId(d.countryId));
                    })
                    .on('click', function (d) {
                        mouseClickGlobal(getCountryNameFromId(d.countryId));
                    })
                    .style("fill", function (d, i) {
                      //console.log(d);
                      return colorInterpolator(linearColorScale(getGrowthInYear(getCountryNameFromId(d.countryId), currentYear)));
                        //todo: Make dependent on growth
                        //return color(d.color = d3.max(neighbors[i], function (n) {
                        //    return nodes[n].color;
                        //}) + 1 | 0);
                    })
                    .style("opacity", function (d) {
                        return d.opacity;
                    });
            force.on("tick", function (e) {
                var q = d3.geom.quadtree(nodes),
                        i = 0,
                        n = nodes.length;
                var k = .5 * e.alpha;
                nodes.forEach(function (o, i) {
                    o.y -= k * (o.y - o.oy);
                    o.x -= k * (o.x - o.ox);
                });
                while (++i < n) {
                    q.visit(collide(nodes[i]));
                }

                node.attr("transform", function (d) {
                    //console.log(d);
                    return "translate(" + d.x + "," + d.y + ")";
                });
            });
            setTimeout(function () {
                force
                        .gravity(0)
                        .charge(0)
                        .nodes(nodes)
                        .links(links)
                        .linkDistance(function (d) {
                            return d.distance;
                        })
                        .start();
                //for (var i = 0; i < 50; ++i) force.tick();
                //force.stop();

                step();
                function step() {


                    isDorling = !isDorling;
                    node.transition()
                            .duration(3000)
                            .attr("d", isDorling
                                    ? function (d) {
                                        return "M" + d.dorling.coordinates.join("L") + "Z";
                                    }
                            : function (d) {
                                return path(d.geometry);
                            })
                            .each("end", function (d) {

                                d = d.dorling;
                                d3.select(this).attr("d", pathCircle(d.centroid[0], d.centroid[1], d.radius));
                            });
                }
            }, 1);
        }

        function getCountryNameFromId(countryId) {
            for (var x = 0; x < countryNames.length; x++) {
                if (countryNames[x].id == countryId) {
                    return countryNames[x].name;
                }
            }
            return "No Name";
        }

        function mouseClickGlobal(countryName) {
            console.log("Clicked " + countryName);
            var lineCountry = findLineCountry(countryName);
            var worldCountry = findMapCountry(countryName);
            if (isCountrySelected(countryName))
            {
                //was contained
                selectedCountries.splice(selectedCountries.indexOf(countryName), 1);
                d3.select(lineCountry.line).classed("country--active", false);
                d3.select(lineCountry.line).style("stroke", "lightgray");
                worldCountry.style({'stroke-opacity': 1, 'stroke-width': '1px', 'stroke': "black"});
                unsetColor(countryName);
            }
            else
            {
                var color = getAndSetAvailableColor(countryName);
                //was not contained yet
                selectedCountries.push(countryName);
                d3.select(lineCountry.line).classed("country--selected", true);
                d3.select(lineCountry.line).style("stroke", color);
                d3.select(lineCountry.line).moveToFront();
                worldCountry.style({'stroke-opacity': 1, 'stroke-width': '3px', 'stroke': color});
            }
            hoverCountry = null;
            drawBubbleChart(internetData);
        }

        function mouseOverGlobal(countryName, redrawBubble) {
            //setFromBubble to false it is was not defined
            redrawBubble = (typeof redrawBubble !== 'undefined' ? redrawBubble : true);
            if (hoverCountry == null)
            {
                console.log("Hovering " + countryName);
                var lineCountry = findLineCountry(countryName);
                var worldCountry = findMapCountry(countryName);
                if (isCountrySelected(countryName))
                {
                    //country was selected, update borders to black
                    d3.select(lineCountry.line).style("stroke", "black");
                    worldCountry.style({'stroke-opacity': 1, 'stroke-width': '4px', 'stroke': "black"});
                } else {
                    d3.select(lineCountry.line).classed("country--active", true);
                    d3.select(lineCountry.line).style("stroke", "red");
                    d3.select(lineCountry.line).moveToFront();
                    worldCountry.style({'stroke-opacity': 1, 'stroke-width': '4px', 'stroke': "red"});
                }

                hoverCountry = countryName;
                if (redrawBubble == true)
                {
                    drawBubbleChart(internetData);
                }
            }

        }

        function mouseOutGlobal(countryName, redrawBubble) {
            //setFromBubble to false it is was not defined
            redrawBubble = (typeof redrawBubble !== 'undefined' ? redrawBubble : true);

            console.log("Left  " + countryName);
            var lineCountry = findLineCountry(countryName);
            var worldCountry = findMapCountry(countryName);
            if (isCountrySelected(countryName))
            {
                d3.select(lineCountry.line).classed("country--active", true);
                d3.select(lineCountry.line).style("stroke", getCountryColor(countryName));
                worldCountry.style({'stroke-opacity': 1, 'stroke-width': '4px', 'stroke': getCountryColor(countryName)});
            } else {
                d3.select(lineCountry.line).classed("country--active", false);
                d3.select(lineCountry.line).style("stroke", "lightgray");
                worldCountry.style({'stroke-opacity': 1, 'stroke-width': '1px', 'stroke': "black"});
            }
            hoverCountry = null;
            if (redrawBubble == true)
            {
                drawBubbleChart(internetData);
            }
        }

        function findMapCountry(countryName) {
            //find the country in the map
            var path = d3.select("#map").select("svg").selectAll("g").select("path").filter(function (d) {
                if (getCountryNameFromId(this.__data__.countryId) === countryName)
                {
                    return this;
                }
            });
            return path;
        }



        function yearSelect() {
            var x = document.getElementById("yearSelect").value;
            currentYear = x;
            resetWorldMap();
            initializeWorldMap(worldData);
        }

        function resetWorldMap() {
            isDorling = false;
            widthMap = document.getElementById("leftColumn").offsetWidth;
            heightMap = document.getElementById("leftColumn").offsetWidth / 1020 * 600;
            projection = d3.geo.mollweide()
                    .scale(180)
                    .translate([widthMap / 2, heightMap / 2]);
            path = d3.geo.path()
                    .projection(projection);
            force = d3.layout.force()
                    .size([widthMap, heightMap]);
            graticule = d3.geo.graticule();
            document.getElementById('map').innerHTML = "";
            svgMap = d3.select("#map").append("svg")
                    .attr("width", widthMap)
                    .attr("height", heightMap + 50);
            svgMap.append("path")
                    .attr("class", "pathMap")
                    .datum({type: "Sphere"})
                    .attr("class", "background")
                    .attr("d", path);
        }

        function exterior(d) {
            switch (d.type) {
                case "Polygon":
                    d.coordinates = [d.coordinates[0]];
                    break;
                case "MultiPolygon":
                    d.coordinates = [[d.coordinates[0][0]]];
                    break;
            }
            return d;
        }

        function projectRing(coordinates) {
            var ring = [];
            d3.geo.stream({type: "Polygon", coordinates: [coordinates]}, projection.stream({
                point: function (x, y) {
                    ring.push([x, y]);
                },
                lineStart: noop,
                lineEnd: noop,
                polygonStart: noop,
                polygonEnd: noop,
                sphere: noop
            }));
            ring.push(ring[0]);
            return ring;
        }

        function mergeNodes(nodes) {
//              console.log(nodes.length);
//              console.log(countryNames.length);
            for (var i = 0; i < countryNames.length; i++) {
                var regions = [];
                for (var j = 0; j < nodes.length; j++) {
                    //console.log(nodes[j].countryId + " " + countryNames[i].id);
                    if (nodes[j].countryId == countryNames[i].id) {
                        regions.push(nodes[j]);
                    }
                }
                //console.log("---------");
                var currentBiggest = null;
                var smallerElements = [];
                regions.forEach(function (r) {
                    if (!currentBiggest) {
                        currentBiggest = r;
                    }
                    else {
                        if (r.dorling.radius > currentBiggest.dorling.radius) {
                            //console.log(r.dorling.radius + " > " + currentBiggest.dorling.radius);
                            currentBiggest.dorling.radius = 0;
                            currentBiggest.opacity = 0;
                            smallerElements.push(currentBiggest);
                            currentBiggest = r;
                        }
                        else {
                            //console.log(r.dorling.radius + " < " + currentBiggest.dorling.radius);
                            r.dorling.radius = 0;
                            r.opacity = 0;
                            smallerElements.push(r);
                        }
                    }
                });
                if (currentBiggest) {
                    currentBiggest.opacity = 1;
                }
                //console.log(smallerElements.length +" | "+ regions.length);
                //console.log("Before remove: " + nodes.length);
                /*smallerElements.forEach(function(e) {
                 
                 var index = nodes.indexOf(e);
                 console.log(e + " at index " + index);
                 nodes.splice(index, 1);
                 
                 });*/
                //console.log("After remove: " + nodes.length);


                //countryNames[i]



            }
        }

        function dorling(d, newRadius) {
            switch (d.type) {
                case "Polygon":
                    return circle(projectRing(d.coordinates[0]), newRadius);
                case "MultiPolygon":
                    return circle(projectRing(d.coordinates[0][0]), newRadius);
            }
            return {radius: 0, coordinates: []};
        }

        // From Mike Bostock’s http://bl.ocks.org/3081153
        function circle(coordinates, newRadius) {
            var circle = [],
                    length = 0,
                    lengths = [length],
                    polygon = d3.geom.polygon(coordinates),
                    p0 = coordinates[0],
                    p1,
                    x,
                    y,
                    i = 0,
                    n = coordinates.length - 1;
            // Compute the distances of each coordinate.
            while (++i < n) {
                p1 = coordinates[i];
                x = p1[0] - p0[0];
                y = p1[1] - p0[1];
                lengths.push(length += Math.sqrt(x * x + y * y));
                p0 = p1;
            }
            var area = polygon.area(),
                    radius = Math.sqrt(newRadius) * 20,
                    //radius = Math.sqrt(Math.abs(area) / Math.PI),
                    centroid = polygon.centroid(-1 / (6 * area)),
                    angleOffset = Math.atan2(coordinates[0][1] - centroid[1], coordinates[0][0] - centroid[0]),
                    angle,
                    i = -1,
                    k = 2 * Math.PI / length;
            // Compute points along the circle’s circumference at equivalent distances.
            while (++i < n) {
                angle = angleOffset + lengths[i] * k;
                circle.push([
                    centroid[0] + radius * Math.cos(angle),
                    centroid[1] + radius * Math.sin(angle)
                ]);
            }
            return {coordinates: circle, radius: radius, centroid: centroid};
        }

        function polygons(geometries) {
            var id = 0;
            return d3.merge(geometries.map(function (geometry) {
                return (geometry.type === "MultiPolygon" ? geometry.arcs : [geometry.arcs]).map(function (d) {
                    return {id: ++id, type: "Polygon", arcs: d, parent: geometry, countryId: geometry.id};
                });
            }));
        }

        // From http://mbostock.github.com/d3/talk/20111018/collision.html
        function collide(node) {
            var r = node.radius,
                    nx1 = node.x - r,
                    nx2 = node.x + r,
                    ny1 = node.y - r,
                    ny2 = node.y + r;
            return function (quad, x1, y1, x2, y2) {
                if (quad.point && (quad.point !== node)) {
                    var x = node.x - quad.point.x,
                            y = node.y - quad.point.y,
                            l = Math.sqrt(x * x + y * y),
                            r = node.dorling.radius + quad.point.dorling.radius;
                    if (l < r) {
                        l = (l - r) / l * .5;
                        node.x -= x *= l;
                        node.y -= y *= l;
                        quad.point.x += x;
                        quad.point.y += y;
                    }
                }
                return x1 > nx2
                        || x2 < nx1
                        || y1 > ny2
                        || y2 < ny1;
            };
        }

        function noop() {
        }

        function pathCircle(x, y, radius) {
            return "M" + x + "," + (y + radius)
                    + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
                    + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
                    + "z";
        }

        function getConnectivity(country, year) {
            var returnValue = "invalid";
            internetData.forEach(function (c) {
                //console.log(c.countryName);
                if (c.countryName == country) {
                    //console.log(c);
                    for (var a in c.values) {
                        //console.log(c.values[a].year);
                        if (c.values[a].year == year) {
                            //console.log("AAAAAAAAAAAA" + c.values[a].value);
                            returnValue = c.values[a].value;
                        }
                        //console.log(a);
                    }
                }
            });
            if (returnValue === "invalid") {
                //console.log(country + " in year " + year + " not found");
                return 0;
            }
            else {
                return returnValue;
            }
        }

        function getGrowthInYear(country, year) {
                //console.log(c.countryName);
                var thisYear = getConnectivity(country, year);
                var previousYear = getConnectivity(country, year-1);
                //console.log(thisYear-previousYear);
                returnValue = thisYear - previousYear;
            return returnValue;
        }

        function setLinearColorScale() {
          var maxValue = 0;
          internetData.forEach(function (c) {
                //console.log(c.countryName);
                var thisYear = getGrowthInYear(c.countryName, currentYear);
                if(thisYear > maxValue) {
                  maxValue = thisYear;
                }
            });

          linearColorScale.domain([0.0, maxValue]);
        }

    </script>
